import os
import csv
from glob import glob
import yaml


#Define and load config
configfile: "config-insecta.yaml"
config = yaml.safe_load(open("config-insecta.yaml"))


#Parse samples from csv
def parse_samples(samples_file):
    print(f"Parsing samples from file: {samples_file}")
    samples = {}
    with open(samples_file, mode='r') as infile:
        reader = csv.DictReader(infile)
        for row in reader:
            sample_id = row['ID']
            forward_read = row['forward']
            reverse_read = row['reverse']
            samples[sample_id] = {"R1": forward_read, "R2": reverse_read}
    print(f"Samples parsed: {samples}")
    return samples

samples = parse_samples(config["samples_file"])
output_dir = config["output_dir"]

print("Samples:", samples)
print(f"Output directory: {output_dir}")



#Rule ALL
rule all:
    input:
        expand(os.path.join(output_dir, "{gene}/{sample}_r_{r}_s_{s}_con_insecta_{gene}.fas"), sample=samples.keys(), gene=config["genes"], r = config["r_params"], s = config["s_params"])



#Rule to ensure necessary directories exist
rule directories_exist:
    output:
        directory(os.path.join(output_dir, "raw_data")),
        directory(os.path.join(output_dir, "trimmed_data")),
    shell:
        """
        mkdir -p {output.raw_data} {output.trimmed_data}
        """



#Rule to handle .fastq.gz files and clean headers
rule gunzip_and_clean_headers:
    input:
        R1=lambda wildcards: samples[wildcards.sample]["R1"],
        R2=lambda wildcards: samples[wildcards.sample]["R2"]
    output:
        R1_temp=os.path.join(output_dir, "raw_data/{sample}_R1_temp.fastq"),
        R2_temp=os.path.join(output_dir, "raw_data/{sample}_R2_temp.fastq")
    shell:
        """
        echo "Decompressing and cleaning headers for {input.R1} and {input.R2}"
        if [[ {input.R1} == *.gz ]]; then
            gzip -cd {input.R1} > {output.R1_temp}
        else
            cp {input.R1} {output.R1_temp}
        fi

        if [[ {input.R2} == *.gz ]]; then
            gzip -cd {input.R2} > {output.R2_temp}
        else
            cp {input.R2} {output.R2_temp}
        fi
        
        sed -i 's/ /_/g' {output.R1_temp}
        sed -i 's/ /_/g' {output.R2_temp}
        """



#Rule to run fastp for PE reads
rule fastp_pe:
    input:
        R1=os.path.join(output_dir, "raw_data/{sample}_R1_temp.fastq"),
        R2=os.path.join(output_dir, "raw_data/{sample}_R2_temp.fastq")
    output:
        R1_trimmed=os.path.join(output_dir, "trimmed_data/{sample}_R1_trimmed.fastq"),
        R2_trimmed=os.path.join(output_dir, "trimmed_data/{sample}_R2_trimmed.fastq"),
        report=os.path.join(output_dir, "trimmed_data/{sample}_fastp_report.html"),
        json=os.path.join(output_dir, "trimmed_data/{sample}_fastp_report.json")
    log:
        out=os.path.join(output_dir, "trimmed_data/{sample}_fastp.out"),
        err=os.path.join(output_dir, "trimmed_data/{sample}_fastp.err")
    shell:
        """
        echo "Running fastp with the following parameters:"
        echo "R1: {input.R1}"
        echo "R2: {input.R2}"
        echo "R1 Trimmed Output: {output.R1_trimmed}"
        echo "R2 Trimmed Output: {output.R2_trimmed}"
        echo "Report Output: {output.report}"
        echo "JSON Output: {output.json}"

        fastp -i {input.R1} -I {input.R2} \
              -o {output.R1_trimmed} -O {output.R2_trimmed} \
              -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA \
              -A AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT \
              --dedup \
              --trim_poly_g \
              -h {output.report} -j {output.json} \
              > {log.out} 2> {log.err}
        """



#Rule to concatenate PE fastq files
rule fastq_concat:
    input:
        R1=os.path.join(output_dir, "trimmed_data/{sample}_R1_trimmed.fastq"),
        R2=os.path.join(output_dir, "trimmed_data/{sample}_R2_trimmed.fastq")
    output:
        temp(os.path.join(output_dir, "trimmed_data/{sample}_concat.fastq"))
    shell:
        """
        echo "Concatenating {input.R1} and {input.R2} to {output}"
        cat {input.R1} {input.R2} > {output}
        """



#Rule to trim concatenated fastq file
rule quality_trim:
    input:
        os.path.join(output_dir, "trimmed_data/{sample}_concat.fastq")
    output:
        os.path.join(output_dir, "trimmed_data/{sample}_concat_trimmed.fq")
    shell:
        """
        echo "Trimming concatenated fastq file {input} to {output}"
        trim_galore --no_report_file --dont_gzip --output_dir {output_dir}/trimmed_data/ {input}
        """


#Rule to run MitoGeneExtractor on trimmed and concatenated fastq file
rule MitoGeneExtractor_diff_params:
    input:
        DNA=os.path.join(output_dir, "trimmed_data/{sample}_concat_trimmed.fq"),
        AA="protein_references/insecta_{gene}.fasta"
    output:
        alignment=os.path.join(output_dir, "{gene}/{sample}_r_{r}_s_{s}_align_insecta_{gene}.fas"),
        consensus=os.path.join(output_dir, "{gene}/{sample}_r_{r}_s_{s}_con_insecta_{gene}.fas"),
        vulgar=os.path.join(output_dir, "{gene}/{sample}_r_{r}_s_{s}_vulgar_insecta_{gene}.txt")
    log:
        out=os.path.join(output_dir, "{gene}/{sample}_r_{r}_s_{s}_summary_insecta_{gene}.out"),
        err=os.path.join(output_dir, "{gene}/{sample}_r_{r}_s_{s}_summary_insecta_{gene}.err")
    shell:
        """
        echo "Running MitoGeneExtractor with the following parameters:"
        echo "DNA: {input.DNA}"
        echo "AA: {input.AA}"
        echo "Alignment Output: {output.alignment}"
        echo "Consensus Output: {output.consensus}"
        echo "Vulgar Output: {output.vulgar}"

        /home/danip3/MitoGeneExtractor-main/MitoGeneExtractor-v1.9.5 \
        -q {input.DNA} -p {input.AA} \
        -o {wildcards.gene}/{wildcards.sample}_r_{wildcards.r}_s_{wildcards.s}_align_insecta_{wildcards.gene}  \
        -c {wildcards.gene}/{wildcards.sample}_r_{wildcards.r}_s_{wildcards.s}_con_insecta_{wildcards.gene}  \
        -V {output.vulgar} \
        -n 0 -t 0.5 -r {wildcards.r} -s {wildcards.s} \
        > {log.out} 2> {log.err}
        """
